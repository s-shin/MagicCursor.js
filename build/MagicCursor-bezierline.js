// Generated by CoffeeScript 1.7.1

/*
MagicCursor-bezierline.js
(C) 2014 Shintaro Seki <s2pch.luck@gmail.com>
The MIT License
 */

(function() {
  MagicCursor.Options.add("bezierline", {
    fps: 30,
    duration: 0.5,
    color: [255, 255, 255],
    lineWidth: 2,
    radius: 5,
    curveStrength: 0.5,
    debug: false,
    draw: function(ctx, points, head, tail) {
      var a, b, ba, baLen, bc, bcLen, c, controlPoints, cp, cp1, cp2, i, k, ma, mamc, mc, mm, mmma, mmmc, p, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _results;
      controlPoints = [];
      if (points.length >= 3) {
        controlPoints.push(null);
        for (i = _i = 1, _ref = points.length - 1; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
          a = points[i - 1];
          b = points[i];
          c = points[i + 1];
          ba = a.sub(b);
          bc = c.sub(b);
          baLen = ba.len();
          bcLen = bc.len();
          ma = b.add(ba.muls(0.5));
          mc = b.add(bc.muls(0.5));
          mamc = mc.sub(ma);
          mm = ma.add(mamc.muls(baLen / (baLen + bcLen)));
          mmma = ma.sub(mm);
          mmmc = mc.sub(mm);
          k = this.curveStrength;
          controlPoints.push([b.add(mmma.muls(k)), b.add(mmmc.muls(k))]);
        }
        controlPoints.push(null);
      }
      if (tail.length > 0) {
        ctx.lineWidth = this.lineWidth;
        ctx.strokeStyle = "rgb(" + (this.color.join(',')) + ")";
        ctx.beginPath();
        if (controlPoints.length > 0) {
          for (i = _j = 0, _ref1 = points.length - 1; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            a = points[i];
            b = points[i + 1];
            if (i === 0) {
              ctx.moveTo(a[0], a[1]);
              cp2 = controlPoints[i + 1][0];
              ctx.quadraticCurveTo(cp2.x, cp2.y, b.x, b.y);
            } else if (i === points.length - 2) {
              cp1 = controlPoints[i][1];
              ctx.quadraticCurveTo(cp1.x, cp1.y, b.x, b.y);
            } else {
              cp1 = controlPoints[i][1];
              cp2 = controlPoints[i + 1][0];
              ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, b.x, b.y);
            }
          }
        } else {
          for (_k = 0, _len = points.length; _k < _len; _k++) {
            p = points[_k];
            ctx.lineTo;
          }
        }
        ctx.stroke();
      }
      if (head) {
        ctx.lineWidth = 0;
        ctx.fillStyle = "rgb(" + (this.color.join(',')) + ")";
        ctx.beginPath();
        ctx.arc(head.x, head.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      if (this.debug) {
        ctx.lineWidth = 2;
        ctx.strokeStyle = "red";
        ctx.fillStyle = "red";
        _results = [];
        for (_l = 0, _len1 = controlPoints.length; _l < _len1; _l++) {
          cp = controlPoints[_l];
          if (!cp) {
            continue;
          }
          ctx.beginPath();
          ctx.moveTo(cp[0].x, cp[0].y);
          ctx.lineTo(cp[1].x, cp[1].y);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cp[0].x, cp[0].y, 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cp[1].x, cp[1].y, 2, 0, Math.PI * 2);
          _results.push(ctx.fill());
        }
        return _results;
      }
    }
  });

}).call(this);
